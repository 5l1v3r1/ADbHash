/*!
\class adb::Hash
\brief The \c Hash<Key, Value, DataType, HashFunction> class provides multi-hash table.
\inmodule ADbHash

It is a template class that can be customized with custom \c DataType
and \c HashFunction. The supplied \c HashFunction must be implicitely
convertible to \c uint64_t taking \c Key as its argument. The
\c DataType must implement all methods that class adb::Data implements.

By allowing different \c DataType classes to be used as internal
storage the \c Hash allows for example in-file storage.

The \c Hash provides dual API to be used as regular hash table or as
a multi-hash implementation allowing for multiple values
with the same key to be stored.

\b {Manipulating Data}

To store data ensuring only a one occurance of a \c Key will exist in
the \c Hash use operator[]. The operator[] will insert new \c Key if it
is not in the \c Hash. If you want to store \c Key with a \c Value
regardless of if there already is one or more use insert(). To replace
a \c Value with another one use replace() that will ensure that nothing
will be stored if the \c Key or \c {Key-Value} pair does not exist.

In order to remove all occurances of a \c Key or \c {Key-Value} pair
from the \c Hash use remove(). If you want to remove only single instance
use erase() that takes adb::Hash::iterator or adb::Hash::const_iterator
as parameter.

To remove all data from the \c Hash use clear().

\note erase() never causes rehashing and returns adb::Hash::iterator or
adb::Hash::const_iteartor pointing to next element after erased one.

\b {Retrieving Data}

There are two principal ways to retrieve data from the \c Hash. Using
adb::Hash::iterator and adb::Hash::const_iterator either by iterating
manually, using ranged-based for or find() methods. Alternatively you
cann access the elements using operator[], value() and values().

You may query the \c Hash for current number of stored elements with
count(), whether it is empty with isEmpty() and the number of elements
associated with a given key with overload of count(). The contains()
overloads can be used to test whether hash has a given \c Key or
\c {Key-Value} pair.
*/

/*
\fn adb::Hash::
*/

/*!
\fn adb::Hash::Hash(std::initializer_list<std::pair<Key, Value>> list)

Constructs the \c Hash with initial values of the \a list.
*/

/*!
\fn iterator adb::Hash::begin()

Returns iterator pointing to first element in the \c Hash
or end() if the \c Hash is empty.
*/

/*!
\fn const_iterator adb::Hash::cbegin() const

Returns const_iterator pointing to first element in the \c Hash
or cend() if the \c Hash is empty.
*/

/*!
\fn const_iterator adb::Hash::cend() const

Returns const_iteartor pointing to element just past the end of the capacity of
the \c Hash.
*/

/*!
\fn void adb::Hash::clear()

Removes all data from the \c Hash and resets its internal storage.
*/

/*!
\fn bool adb::Hash::contains(const Key &key) const

Returns \c true if there is at least one occurance of \a key in
the \c Hash.
*/

/*!
\fn void adb::Hash::contains(const Key &key, const Value &value) const

Returns \c true if there is at least one occurance of \a key and \a value
pair in the \c Hash.
*/

/*!
\fn int64_t adb::Hash::count() const

Returns number of elements in the \c Hash.
*/

/*!
\fn int64_t adb::Hash::count(const Key &key) const

Returns number of elements with the \a key in the \c Hash.
*/

/*!
\fn iterator adb::Hash::end()

Returns iterator pointing to element just past the end of the capacity of
the \c Hash.
*/

/*!
\fn const_iterator adb::Hash::erase(const_iterator it)

Removes element pointed to by \a it from the \c Hash. Returns const_iterator
pointing to the next element after the element being erased or end() if \a it
pointed to the last element.

\note This method never causes rehashing of the \c Hash.
*/

/*!
\fn iterator adb::Hash::erase(iterator it)

Removes element pointed to by \a it from the \c Hash. Returns iterator
pointing to the next element after the element being erased or end() if \a it
pointed to the last element.

\note This method never causes rehashing of the \c Hash.
*/

/*!
\fn const_iterator adb::Hash::find(const Key &key) const

Returns const_iterator to first element with \a key or cend() if the \a key is not
in the \c Hash. If there are more occurances of \a key in the \c Hash their order
is undefined.
*/

/*!
\fn const_iterator adb::Hash::find(const Key &key, const Value &value) const

Returns const_iterator to first element with \a key and \a value or cend() if the \a key
with \a value is not in the \c Hash. If there are more occurances of \a key and \a value
pairs in the \c Hash their order is undefined.
*/

/*!
\fn iterator adb::Hash::find(const Key &key)

Returns iterator to first element with \a key or end() if the \a key is not
in the \c Hash. If there are more occurances of \a key in the \c Hash their order
is undefined.
*/

/*!
\fn iterator adb::Hash::find(const Key &key, const Value &value)

Returns iterator to first element with \a key and \a value or end() if the \a key
with \a value is not in the \c Hash. If there are more occurances of \a key and \a value
pairs in the \c Hash their order is undefined.
*/

/*!
\fn iterator adb::Hash::insert(const Key &key, const Value &value)

Inserts new \a key with \a value as new element to the \c Hash. The \c Hash
table might rehash. If there already is \a key this method will simply insert
new one. If you want to replace a value with another use replace(). If you want
to insert new or replace existing value use operator[].
*/

/*!
\fn bool adb::Hash::isEmpty() const

Returns \c true if there are no elements stored in the \c Hash.
*/

/*!
\fn Reference<Value, DataType> adb::Hash::operator[](const Key &key)

Returns Reference object wrapping the hash data and index pointing to the
\a key 's first occurance. If there are no \a key in the \c Hash new one
will be inserted possibly causing rehashing of the table. Returned Reference
is assignable.
*/

/*!
\fn Value adb::Hash::operator[](const Key &key) const

Same as value().
*/

/*!
\fn void adb::Hash::replace(const Key &key, const Value &newValue)

Replaces first occurance's value of \a key with \a newValue. If there
are more occurances of \a key in the \c Hash their order is undefined.
If there are no elements with \a key this method does nothing (it does
not insert new element). Consider using overloaded method that takes
old value as additional parameter if there are multiple values
associated with the \a key.
*/

/*!
\fn void adb::Hash::replace(const Key &key, const Value &oldValue, const Value &newValue)

Replaces first occurance of \a key - \a oldValue pair with \a newValue. If there
are more occurances of \a key - \a oldValue pair in the \c Hash their order
is undefined. If there are no elements with \a key this method does nothing
(it does not insert new element). Consider using overloaded method that takes
old value as additional parameter if there are multiple values
associated with the \a key.
*/

/*!
\fn void adb::Hash::remove(const Key &key)

Removes all occurances of \a key from the \c Hash.
*/

/*!
\fn void adb::Hash::remove(const Key &key, const Value &value)

Removes all occurances of \a key with \a value from the \c Hash.
*/

/*!
\fn Value adb::Hash::value(const Key &key, const Value &defaultValue) const

Returns Value associated with the \a key or default constructed \c Value
if there is no element with \a key. If there are more occurances of \a key
in the \c Hash their order is undefined. Unlike operator[] you can specify
your own \a defaultValue.
*/

/*!
\fn std::vector<Value> adb::Hash::values(const Key &key) const

Returns \c {list of all values} associated with \a key or empty \c list
if the \a key is not in the \c Hash.
*/
